#!/bin/bash
# this is called the shebang. It tells the script to use the bash shell to run in.
# "#!/bin/env bash" also does the trick.
# packages installed specifically for this script are 'smbclient' and 'cifs-utils'.

# every term before the '=' is a variable name
SERVER="192.168.29.123"
# SERVER is the ip address of the network
SHARE="//${SERVER}/s10scans"
# SHARE is the address to the host directory in the windows system where SERVER is expanded to get ...
# ... "//192.168.29.123/s10scans"
MOUNTPOINT="$HOME/winshare"
# MOUNTPOINT is the location on this system where we want to access the windows directrory ...
# ... $HOME is the system path variable, so MOUNTPOINT expands to ...
# ... /home/sumodk/winshare
MY_UID=$(id -u)
# UID is capturing the user id, 1000 in this case as there is only a single user.
MY_GID=$(id -g)
# GID is capturing the group id ... It is required to ensure that when files are accessed on Linux ...
# ... the user has the requred permissions. Else all files will be root user access only.
OPTIONS="username=S10DIGITAL,password=,vers=3.0"
# OPTIONS stores the literal string in double quotes.
# vers=3.0 tells Linux CIFS client to use SMB 3.0 when talking the Windows Server.

case "$1" in
  # '\n' is used to denote a new line
  # case ... in \n condition) \n ... ... \n ;; \n condition) \n ... ... \n ;; \n default) \n ... ... \n ;; \n esac
  # this is the syntax for case statements, a cleaner substitute for the if statements.
  # here the input is "$1", the first argument given to the command used to run this script ("winshare" in this case)
  # so it is effectively saying, 'in the case where the first argument is'
  # disconnect) is one condition handle used in this block and the other is anyother/default condition handle denoted by the *.
  disconnect) # this is telling the case statement to execute the block if the given argument is "disconnect"
    if mountpoint -q "$MOUNTPOINT"; then
  # if ... ... ... ... ; then \n ... ... \n else or elseif \n ...........\n fi 
  # this is the syntax for the if conditional statements.
  # mountpoint is a shell command checking a mount locaction is accessed.
  # here it is stating, if mountpoint (- q means quietly, no error messages) is equal to /home/sumodk/winshare then
  # so if the statement eveluates to TRUE, meaning if already mounted then
      echo "Unmounting $MOUNTPOINT..."
  # echo is the command to print string to the terminal screen
  # "Unmounting /home/sumodk/winshare" will be printed to the terminal.
      sudo umount "$MOUNTPOINT" && echo "Unmounted successfully."
  # this line holds two commands, the sudo umount and the echo.
  # the command after the && will run only if the previous command runs successfully.
  # sudo is leveraging the root user access and umount is disengaging /home/sumodk/winshare from the mountpoint
  # if successful then echo prints the string in "" to the terminal
    else # the else condition i.e. if there is nothing mounted at /home/sumodk/winshare
      echo "Nothing mounted at $MOUNTPOINT."
  # mountpoint found no path engaged.
    fi # closing the if condition statemnent
    ;; # closing the first condition of the case statement
  *) # the default, for all other condition not targeted by the previous case handles.
    if mountpoint -q "$MOUNTPOINT"; then
  # if mountpoint is equal to /home/sumodk/winshare, then
      echo "Already mounted at $MOUNTPOINT"
  # since it is already mounted print the info
      exit 0 # exit the case function with success status. exit 0 is success and exit 1 is error
    fi # closing the if condition statemnent

    if ping -c 1 -W 2 "$SERVER" > /dev/null; then
      # ping once (-count 1), wait 2 seconds (-Wait 2) the ip address stored in the variable SERVER.
      # this will send 1 ping [one Internet Control Message Protocl (ICMP)] to 192.168.29.123 ...
      # and if exit status is 0 then proceed.
      # the > is redirecting all standard output (stdout) generated by the ping command to a linux black hole --> /dev/null
      echo "Server reachable, mounting..."
      # prints string to terminal
      sudo mount -t cifs "$SHARE" "$MOUNTPOINT" -o "$OPTIONS,uid=$MY_UID,gid=$MY_GID" && echo "Mounted Windows share at $MOUNTPOINT"
  # sudo is leveraging the root user access and mount is loading the directory received from $SHARE to /home/sumodk/winshare
  # -o is the options
  # mount -t cifs --> cifs is Common Internet File System, the package installed to enable accessing files on Windows
  # mount is the command to mount the directory [-t (-type) is what tells the mount command what file will be mounted] recieved,
  # cifs tells that the file to be mounted is from a shared location
  # $SHARE (192.168.29.123) --> mount from
  # to /home/sumodk/winshare ($MOUNTPOINT)
  # -o (the aptions passed) all variables defined at the start
  # && concatentating a command that executes only if the previous command runs successfully
  # echo --> printing the string literal to the terminal, the variable is expanded to its raw content
    else # the else condition
      echo "Server $SERVER not reachable."
      exit 1 # quits the case function creating an error status 
    fi # closing the if condition statement
  ;; # closing the current case condition
esac # closing the case function
